


#include<iostream>
#include<stdio.h>
#define inf 0x3f3f3f3f
using namespace std;

const int maxn=1000;
int a[maxn][maxn];
int n;//n个节点,m条路
bool vis[maxn];
int cost=inf;
int tmpcost;
int start;
int ans[maxn];
int tmpans[maxn];
int sum;

void dfs(int a[maxn][maxn],int cur,int cnt)
{
    if(cnt==n-1)
    {

        sum++;
        if(tmpcost+a[cur][start]<cost)
        {
            cost=tmpcost+a[cur][start];
            tmpans[cnt+1]=start;
            for(int i=0;i<n;i++)
            {
                ans[i]=tmpans[i];
            }
        }
        return;
    }
    else
    {
        for(int i=0;i<n;i++)
        {
            if(i!=cur)
            {
                if(!vis[i]&&tmpcost+a[cur][i]<cost)
            {
                tmpcost+=a[cur][i];
                vis[i]=true;
                tmpans[cnt+1]=i;
                dfs(a,i,cnt+1);
                tmpcost-=a[cur][i];
                vis[i]=false;
            }
            }

        }
    }
}
int main()
{
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);
   cin>>n;

   cin>>start;
   start--;


   vis[start]=true;


   for(int i=0;i<n;i++)
   {
       for(int j=0;j<n;j++)
       {
           a[i][j]=inf;
           a[j][i]=inf;
       }
   }
   int m;
   m=(-n+n*n)/2;
   while(m--)
   {

       int u,v,val;
       cin>>u>>v>>val;
       u--;
       v--;
       a[u][v]=val;
       a[v][u]=val;

   }
    int cnt=0;
    tmpans[cnt]=start;
   dfs(a,start,cnt);
   cout<<cost<<endl;
   for(int i=0;i<n;i++)
    cout<<ans[i]<<endl;
    fclose(stdin);



}


45
2
1
0
3

Process returned 0 (0x0)   execution time : 0.255 s


4 
3
1 2 20
1 4 3
1 3 34
2 4 5
2 3 6
3 4 16



//modify bestc; I don't think it performs better.


#include<iostream>
#include<stdio.h>
#define inf 0x3f3f3f3f
using namespace std;

const int maxn=1000;
int a[maxn][maxn];
int n;//n个节点,m条路
bool vis[maxn];
int bestc=0;
int tmpcost;
int start;
int ans[maxn];
int tmpans[maxn];
int sum;

void dfs(int a[maxn][maxn],int cur,int cnt)
{
    if(cnt==n-1)
    {

        sum++;
        if(tmpcost+a[cur][start]<bestc)
        {
            bestc=tmpcost+a[cur][start];
            tmpans[cnt+1]=start;
            for(int i=0;i<n;i++)
            {
                ans[i]=tmpans[i];
            }
        }
        return;
    }
    else
    {
        for(int i=0;i<n;i++)
        {
            if(i!=cur)
            {
                if(!vis[i]&&tmpcost+a[cur][i]<bestc)
            {
                tmpcost+=a[cur][i];
                vis[i]=true;
                tmpans[cnt+1]=i;
                dfs(a,i,cnt+1);
                tmpcost-=a[cur][i];
                vis[i]=false;
            }
            }

        }
    }
}
int main()
{
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);
   cin>>n;

   cin>>start;
   start--;


   vis[start]=true;


   for(int i=0;i<n;i++)
   {
       for(int j=0;j<n;j++)
       {
           a[i][j]=inf;
           a[j][i]=inf;
       }
   }
   int m;
   m=(-n+n*n)/2;
   int maxnn[n];
   for(int i=0;i<n;i++)
    maxnn[i]=-1;
   while(m--)
   {

       int u,v,val;
       cin>>u>>v>>val;
       u--;
       v--;
       a[u][v]=val;
       a[v][u]=val;
       if(maxnn[u]<val)maxnn[u]=val;
       if(maxnn[v]<val)maxnn[v]=val;

   }

   for(int i=0;i<n;i++)bestc+=maxnn[i];

    int cnt=0;
    tmpans[cnt]=start;
   dfs(a,start,cnt);
   cout<<bestc<<endl;
   for(int i=0;i<n;i++)
    cout<<ans[i]<<endl;
    fclose(stdin);



}
45
2
1
0
3

Process returned 0 (0x0)   execution time : 0.401 s




//add a lowerbound based on the last one; performmance imporved; see runtime;

#include<iostream>  
#include<stdio.h>  
#define inf 0x3f3f3f3f  
using namespace std;  
  
const int maxn=1000;  
int a[maxn][maxn];  
int n;//n个节点,m条路  
bool vis[maxn];  
int bestc=1;  
int low=0;  
int tmpcost;  
int start;  
int ans[maxn];  
int tmpans[maxn];  
int sum;  
  
void dfs(int a[maxn][maxn],int cur,int cnt)  
{  
    if(cnt==n-1)  
    {  
  
        sum++;  
        if(tmpcost+a[cur][start]<bestc&&tmpcost+a[cur][start]>=low)  
        {  
            bestc=tmpcost+a[cur][start];  
            tmpans[cnt+1]=start;  
            for(int i=0;i<n;i++)  
            {  
                ans[i]=tmpans[i];  
            }  
        }  
        return;  
    }  
    else  
    {  
        for(int i=0;i<n;i++)  
        {  
            if(i!=cur)  
            {  
                if(!vis[i]&&tmpcost+a[cur][i]<bestc&&tmpcost+a[cur][start]>=low)  
            {  
                tmpcost+=a[cur][i];  
                vis[i]=true;  
                tmpans[cnt+1]=i;  
                dfs(a,i,cnt+1);  
                tmpcost-=a[cur][i];  
                vis[i]=false;  
            }  
            }  
  
        }  
    }  
}  
int main()  
{  
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);  
   cin>>n;  
  
   cin>>start;  
   start--;  
  
  
   vis[start]=true;  
  
  
   for(int i=0;i<n;i++)  
   {  
       for(int j=0;j<n;j++)  
       {  
           a[i][j]=inf;  
           a[j][i]=inf;  
       }  
   }  
   int m;  
   m=(-n+n*n)/2;  
   int maxnn[n];  
   int minn[n];  
   for(int i=0;i<n;i++)  
    minn[i]=inf;  
   for(int i=0;i<n;i++)  
    maxnn[i]=-1;  
   while(m--)  
   {  
  
       int u,v,val;  
       cin>>u>>v>>val;  
       u--;  
       v--;  
       a[u][v]=val;  
       a[v][u]=val;  
       if(maxnn[u]<val)maxnn[u]=val;  
       if(maxnn[v]<val)maxnn[v]=val;  
       if(minn[u]>val)minn[u]=val;  
       if(minn[v]>val)minn[v]=val;  
  
   }  
  
   for(int i=0;i<n;i++)bestc+=maxnn[i];  
   for(int i=0;i<n;i++)low+=minn[i];  
  
    int cnt=0;  
    tmpans[cnt]=start;  
   dfs(a,start,cnt);  
   cout<<bestc<<endl;  
   for(int i=0;i<n;i++)  
    cout<<ans[i]<<endl;  
    fclose(stdin);  
  
  
  
}  
45
2
3
0
1

Process returned 0 (0x0)   execution time : 0.281 s




//textbook implementation; backtrace




#include<iostream>
#include<stdio.h>
using namespace std;
int n,m;
const int maxn=1000;
int a[maxn][maxn];
int NoEdge=0;
int bestc;
int x[maxn];
int bestx[maxn];
int cc=0;
int cnt;

void Backtrack(int i)
{
    ++cnt;
    if(i==n)
    {
        if(a[x[n-1]][x[n]]!=NoEdge&&a[x[n]][x[1]]!=NoEdge&&
           (cc+a[x[n-1]][x[n]]+a[x[n]][x[1]]<bestc||bestc==NoEdge))
        {
            for(int j=1;j<=n;j++)
                bestx[j]=x[j];
            bestc=cc+a[x[n-1]][x[n]]+a[x[n]][1];
        }
    }
    else
    {
        for(int j=i;j<=n;j++)
        {
            if(a[x[i-1]][x[j]]!=NoEdge&&(cc+a[x[i-1]][x[j]]<bestc||bestc==NoEdge))
            {
                swap(x[i],x[j]);
                cc+=a[x[i-1]][x[i]];
                Backtrack(i+1);
                cc-=a[x[i-1]][x[i]];
                swap(x[i],x[j]);
            }
        }
    }
}
int main()
{
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);
    cout<<"节点数："<<endl;
    cin>>n;
    cout<<n<<endl;
    cout<<"边数："<<endl;
    m=(-n+n*n)/2;
    cout<<m<<endl;
    int st;
    cin>>st;
     cout<<"起点："<<st<<endl;
     cout<<endl;
    int u,v,w;
    for(int i=1;i<=m;i++)
    {
        cout<<"第"<<i<<"条边："<<endl;
        cin>>u>>v>>w;
        cout<<"("<<u<<","<<v<<"):"<<w<<endl;
        a[u][v]=w;
        a[v][u]=w;
    }
    cout<<endl;
    for(int i=1;i<=n;i++)x[i]=i;
    x[1]=st;
    Backtrack(2);
    cout<<"回溯次数："<<cnt<<endl;
    cout<<"最小费用："<<bestc<<endl;
    cout<<"路径："<<endl;
    for(int i=1;i<=n;i++)
        cout<<bestx[i]<<" ";
    fclose(stdin);
}

input
5 
2
1 2 20
1 3 2
1 4 4
1 5 15
2 3 23
2 4 7
2 5 9
3 4 12
3 5 76
4 5 33

output
节点数：
5
边数：
10
起点：2

第1条边：
(1,2):20
第2条边：
(1,3):2
第3条边：
(1,4):4
第4条边：
(1,5):15
第5条边：
(2,3):23
第6条边：
(2,4):7
第7条边：
(2,5):9
第8条边：
(3,4):12
第9条边：
(3,5):76
第10条边：
(4,5):33

回溯次数：21
最小费用：39
路径：
2 5 2 4 3



5-5
#include<iostream>
#include<stdio.h>
using namespace std;
int n,m;
const int maxn=1000;
int a[maxn][maxn];
int maxnn[maxn];
int NoEdge=0;
int bestc;
int x[maxn];
int bestx[maxn];
int cc=0;
int cnt;
int summaxnn=1;

void Backtrack(int i)
{
    ++cnt;
    if(i==n)
    {
        if(a[x[n-1]][x[n]]!=NoEdge&&a[x[n]][x[1]]!=NoEdge&&
           (cc+a[x[n-1]][x[n]]+a[x[n]][x[1]]<bestc))
        {
            for(int j=1;j<=n;j++)
                bestx[j]=x[j];
            bestc=cc+a[x[n-1]][x[n]]+a[x[n]][1];
        }
    }
    else
    {
        for(int j=i;j<=n;j++)
        {
            if(a[x[i-1]][x[j]]!=NoEdge&&(cc+a[x[i-1]][x[j]]<bestc))
            {
                swap(x[i],x[j]);
                cc+=a[x[i-1]][x[i]];
                Backtrack(i+1);
                cc-=a[x[i-1]][x[i]];
                swap(x[i],x[j]);
            }
        }
    }
}
int main()
{
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);
    cout<<"节点数："<<endl;
    cin>>n;
    cout<<n<<endl;
    cout<<"边数："<<endl;
    m=(-n+n*n)/2;
    cout<<m<<endl;
    int st;
    cin>>st;
     cout<<"起点："<<st<<endl;
     cout<<endl;
    int u,v,w;
    for(int i=1;i<=m;i++)
    {
        cout<<"第"<<i<<"条边："<<endl;
        cin>>u>>v>>w;
        cout<<"("<<u<<","<<v<<"):"<<w<<endl;
        a[u][v]=w;
        a[v][u]=w;
        if(maxnn[u]<w)maxnn[u]=w;
        if(maxnn[v]<w)maxnn[v]=w;
    }
    cout<<endl;
    for(int i=1;i<=n;i++)summaxnn+=maxnn[i];
    bestc=summaxnn;
    cout<<"初始bestc为："<<bestc<<endl;
    cout<<endl;
    for(int i=1;i<=n;i++)x[i]=i;
    x[1]=st;
    Backtrack(2);
    cout<<"回溯次数："<<cnt<<endl;
    cout<<"最小费用："<<bestc<<endl;
    cout<<"路径："<<endl;
    for(int i=1;i<=n;i++)
        cout<<bestx[i]<<" ";
    fclose(stdin);
}
输出：
节点数：
5
边数：
10
起点：2

第1条边：
(1,2):20
第2条边：
(1,3):2
第3条边：
(1,4):4
第4条边：
(1,5):15
第5条边：
(2,3):23
第6条边：
(2,4):7
第7条边：
(2,5):9
第8条边：
(3,4):12
第9条边：
(3,5):76
第10条边：
(4,5):33

初始bestc为：229

回溯次数：21
最小费用：39
路径：
2 5 2 4 3





#include<iostream>
#include<stdio.h>
#define inf 0x3f3f3f3f
using namespace std;
int n,m;
const int maxn=1000;
int a[maxn][maxn];
int minn[maxn];
int maxnn[maxn];
int NoEdge=0;
int bestc=1;
int x[maxn];
int bestx[maxn];
int cc=0;
int cnt;


void Backtrack(int i)
{
    ++cnt;
    if(i==n)
    {
        if(a[x[n-1]][x[n]]!=NoEdge&&a[x[n]][x[1]]!=NoEdge&&
           (cc+a[x[n-1]][x[n]]+a[x[n]][x[1]]<bestc))
        {
            for(int j=1;j<=n;j++)
                bestx[j]=x[j];
            bestc=cc+a[x[n-1]][x[n]]+a[x[n]][1];
        }
    }
    else
    {
        for(int j=i;j<=n;j++)
        {
            int summinn=0;
            for(int k=j;k<=n;k++)
            {
                summinn+=minn[x[k]];
            }
            if(a[x[i-1]][x[j]]!=NoEdge&&(cc+summinn<bestc))
            {
                swap(x[i],x[j]);
                cc+=a[x[i-1]][x[i]];
                Backtrack(i+1);
                cc-=a[x[i-1]][x[i]];
                swap(x[i],x[j]);
            }
        }
    }
}
int main()
{
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);
    cout<<"节点数："<<endl;
    cin>>n;
    cout<<n<<endl;
    cout<<"边数："<<endl;
    m=(-n+n*n)/2;
    cout<<m<<endl;
    int st;
    cin>>st;
     cout<<"起点："<<st<<endl;
     cout<<endl;
     for(int i=1;i<=n;i++)minn[i]=inf;
     cout<<endl;
    int u,v,w;
    for(int i=1;i<=m;i++)
    {
        cout<<"第"<<i<<"条边："<<endl;
        cin>>u>>v>>w;
        cout<<"("<<u<<","<<v<<"):"<<w<<endl;
        a[u][v]=w;
        a[v][u]=w;
        if(minn[u]>w)minn[u]=w;
        if(minn[v]>w)minn[v]=w;
        if(maxnn[u]<w)maxnn[u]=w;
        if(maxnn[v]<w)maxnn[v]=w;
    }
    cout<<endl;
    for(int i=1;i<=n;i++)bestc+=maxnn[i];
    cout<<"bestc初始为："<<bestc<<endl;
    for(int i=1;i<=n;i++)x[i]=i;
    x[1]=st;
    Backtrack(2);
    cout<<"回溯次数："<<cnt<<endl;
    cout<<"最小费用："<<bestc<<endl;
    cout<<"路径："<<endl;
    for(int i=1;i<=n;i++)
        cout<<bestx[i]<<" ";
    fclose(stdin);
}
input
5 
2
1 2 2
1 3 2
1 4 4
1 5 5
2 3 3
2 4 7
2 5 9
3 4 2
3 5 7
4 5 3
output
节点数：
5
边数：
10
起点：2


第1条边：
(1,2):2
第2条边：
(1,3):2
第3条边：
(1,4):4
第4条边：
(1,5):5
第5条边：
(2,3):3
第6条边：
(2,4):7
第7条边：
(2,5):9
第8条边：
(3,4):2
第9条边：
(3,5):7
第10条边：
(4,5):3

bestc初始为：38
回溯次数：30
最小费用：21
路径：
2 3 2 4 5



#include<bits/stdc++.h>
using namespace std;
const int maxn=100;

int n,m;
class Traveling
{
    friend TSP(int**, int[], int, int);
private:
    void Backtrack(int i);
    int n;
    *x,
    *bestx;
    int **a,
    cc,
    bestc,
    NoEdge;

};
void Make2DArray(int **&x,int rows,int cols)
{
    // 创建一个行指针
    x=new int *[rows];
    for(int i=0;i<rows;i++)
    {
        x[i]=new int [cols];
    }

}
void Traveling::Backtrack(int i)
{
    cout<<endl;
    cout<<endl;
    cout<<"i=="<<i<<endl;
    if(i==n)
    {
        if(a[x[n-1]][x[n]]!=NoEdge&&a[x[n]][1]!=NoEdge&&
           (cc+a[x[n-1]][x[n]]+a[x[n]][1]<bestc||bestc==NoEdge)){
            for(int j=1;j<=n;j++)
                bestx[j]=x[j];
            bestc=cc+a[x[n-1]][x[n]]+a[x[n]][1];
           }
    }
    else
    {
        cout<<"else"<<endl;
        for(int j=i;j<=n;j++)
        {

            if(a[x[i-1]][x[j]]!=NoEdge&&(cc+a[x[i-1]][x[j]]<bestc||bestc==NoEdge))
            {
                cout<<"x["<<i<<"]=="<<x[i]<<endl;
                cout<<"x["<<j<<"]=="<<x[j]<<endl;
                swap(x[i],x[j]);
                cout<<x[i-1]<<endl;
                cout<<x[i]<<endl;


                 cc+=a[x[i-1]][x[i]];
                Backtrack(i+1);
                 cc-=a[x[i-1]][x[i]];
                swap(x[i],x[j]);
            }
        }
    }
}
int TSP(int **a,int v[],int n,int NoEdge)
{

    cout<<"TSP"<<endl;
    Traveling Y;
    Y.x=new int [n+1];
    for(int i=1;i<=n;i++)
        Y.x[i]=i;
    Y.a=a;
    Y.n=n;
    Y.bestc=NoEdge;
    Y.bestx=v;
    Y.cc=0;
    Y.NoEdge=NoEdge;
    cout<<"***"<<endl;
    Y.Backtrack(2);
    delete [] Y.x;
    return Y.bestc;
}
int main()
{
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);
    int **a;
    int v[maxn];
    Make2DArray(a,maxn,maxn);
    cin>>n;
    cout<<n<<endl;
    int cost;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>cost;
            a[i][j]=cost;
        }

    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {

            cout<<a[i][j]<<" ";
        }
        cout<<endl;
    }

    /*for(int i=1;i<=m;i++)
    {
        cout<<"i=="<<i<<endl;
        cin>>st>>nd>>cost;
         cout<<"st=="<<st<<endl;
        cout<<"nd=="<<nd<<endl;
        cout<<"cost=="<<cost<<endl;
        a[st][nd]=cost;
        v[i]=cost;

    }*/
    cout<<"out"<<endl;
    cout<<TSP(a,v,n,0)<<endl;
    fclose(stdin);



}

input
4
0 30 6 4
30 0 5 10
6 5 0 20
4 10 20 0
output
4
0 30 6 4
30 0 5 10
6 5 0 20
4 10 20 0
out
TSP
***


i==2
else
x[2]==2
x[2]==2
1
2


i==3
else
x[3]==3
x[3]==3
2
3


i==4
x[3]==3
x[4]==4
2
4


i==4
x[2]==2
x[3]==3
1
3


i==3
else
x[3]==2
x[3]==2
3
2


i==4
x[2]==2
x[4]==4
1
4


i==3
else
x[3]==3
x[3]==3
4
3


i==4
x[3]==3
x[4]==2
4
2


i==4
25



//教材实现：
#include<iostream>
#include<stdio.h>
using namespace std;

const int cols=100;
const int rows=100;
class Traveling
{
    friend int TSP(int**,int[],int,int);
private:
    void Backtrack(int i);
    int n,
    *x,
    *bestx,
    **a,
    cc,
    bestc,
    NoEdge;
};
void Traveling::Backtrack(int i)
{
    if(i==n)
    {
        if(a[x[n-1]][x[n]]!=NoEdge&&a[x[n]][1]!=NoEdge&&
           (cc+a[x[n-1]][x[n]]+a[x[n]][1]<bestc||bestc==NoEdge))
        {
            for(int j=1;j<=n;j++)
            {
                bestx[j]=x[j];
            }
            bestc=cc+a[x[n-1]][x[n]]+a[x[n]][1];
        }
    }
    else
    {
        for(int j=i;j<=n;j++)
        {
            if(a[x[i-1]][x[j]]!=NoEdge&&(cc+a[x[i-1]][x[j]]<bestc||bestc==NoEdge))
            {
                swap(x[i],x[j]);
                cc+=a[x[i-1]][x[i]];
                Backtrack(i+1);
                cc-=a[x[i-1]][x[i]];
                swap(x[i],x[j]);
            }
        }
    }
}
void make2dArray(int ** & x,int rows, int cols){
    x = new int*[rows];
    for (int i = 0; i < rows; ++i)
    {
        x[i] = new int[cols];
    }
}
int TSP(int**a, int v[], int n, int NoEdge)
{
    Traveling Y;
    Y.x=new int [n+1];
    for(int i=1;i<=n;i++)
    {
        Y.x[i]=i;
    }
    Y.a=a;
    Y.n=n;
    Y.bestc=NoEdge;
    Y.bestx=v;
    Y.cc=0;
    Y.NoEdge=NoEdge;
    Y.Backtrack(2);
    delete [] Y.x;
    return Y.bestc;
}

int main()
{
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);
    int n;
    cin>>n;
    cout<<"城市个数："<<n<<endl;
    int **a;
    make2dArray(a,rows,cols);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
        }
    }
     cout<<"图的矩阵形式："<<endl;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cout<<a[i][j]<<" ";
        }
        cout<<endl;
    }
    int *m;
    m=new int[100];
    int *bestx;
    int sum;
    sum=TSP(a,m,n,0);
    cout<<"最优路线："<<endl;
    for(int i=1;i<=n;i++)
    {
        cout<<m[i]<<" ";
    }
    cout<<endl;
    cout<<"最小费用："<<endl;
    cout<<sum<<endl;
    fclose(stdin);

}

输入：
4
0 22 7 4
22 0 5 4
7 5 0 11
4 4 11 0
输出：
城市个数：4
图的矩阵形式：
0 22 7 4
22 0 5 4
7 5 0 11
4 4 11 0
最优路线：
1 3 2 4
最小费用：
20


//5-5
#include<iostream>
#include<stdio.h>
using namespace std;

const int cols=100;
const int rows=100;

class Traveling
{

    friend int TSP(int**, int[], int, int);
private:
    void Backtrack(int i);
    int n,
    *x,
    *bestx,
    **a,
    cc,
    bestc,
    NoEdge;
};
void make2dArray(int ** & x,int rows, int cols){
    x = new int*[rows];
    for (int i = 0; i < rows; ++i)
    {
        x[i] = new int[cols];
    }
}
void Traveling::Backtrack(int i)
{
    if(i==n)
    {
        if(a[x[n-1]][x[n]]!=NoEdge&&a[x[n]][1]!=NoEdge&&
           (cc+a[x[n-1]][x[n]]+a[x[n]][1]<bestc||bestc==NoEdge))
        {
            for(int j=1;j<=n;j++)
            {
                bestx[j]=x[j];
            }
            bestc=cc+a[x[n-1]][x[n]]+a[x[n]][1];
        }
    }
    else
    {
        for(int j=i;j<=n;j++)
        {
            if(a[x[i-1]][x[j]]!=NoEdge&&(cc+a[x[i-1]][x[j]]<bestc||bestc==NoEdge))
            {
                swap(x[i],x[j]);
                cc+=a[x[i-1]][x[i]];
                Backtrack(i+1);
                cc-=a[x[i-1]][x[i]];
                swap(x[i],x[j]);
            }
        }
    }
}
int TSP(int**a, int v[],int n,int NoEdge)
{
    Traveling Y;
    Y.x=new int [n+1];
    for(int i=1;i<=n;i++)
        Y.x[i]=i;
    Y.a=a;
    Y.n=n;
    Y.bestc=NoEdge;
    Y.bestx=v;
    Y.cc=0;
    Y.NoEdge=NoEdge;
    Y.Backtrack(2);
    delete [] Y.x;
    return Y.bestc;
}
int main()
{
    freopen("C:\\Users\\lenovo\\Desktop\\tmp.txt","r",stdin);
    int **a;
    int *m;
    int *bestc;
    make2dArray(a,rows,cols);
    int large[100];
    int n;
    cin>>n;
    cout<<"城市个数："<<n<<endl;
    for(int i=1;i<=n;i++)
    {
        large[i]=-9;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
            if(large[i]<a[i][j])
                large[i]=a[i][j];

        }
    }
    for(int i=1;i<=n;i++)bestc+=large[i];
    cout<<"图的矩阵形式："<<endl;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cout<<a[i][j]<<" ";
        }
        cout<<endl;
    }
    int sum;
    sum=TSP(a,m,n,0);
     cout<<"最优路线："<<endl;
    for(int i=1;i<=n;i++)
    {
        cout<<m[i]<<" ";
    }
    cout<<endl;
    cout<<"最小费用："<<endl;
    cout<<sum<<endl;

}
输入：
4
0 22 7 4
22 0 5 4
7 5 0 11
4 4 11 0
输出：
城市个数：4
图的矩阵形式：
0 22 7 4
22 0 5 4
7 5 0 11
4 4 11 0
最优路线：
1 3 2 4
最小费用：
20





